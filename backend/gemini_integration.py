import os
import google.generativeai as genai
from dotenv import load_dotenv
from flask import current_app

# Load environment variables
load_dotenv()

# Get the Gemini API key from the environment variables
api_key = os.getenv("GEMINI_API_KEY")

if not api_key:
    raise ValueError("GEMINI_API_KEY environment variable not set.")

# Configure the Gemini API 
genai.configure(api_key=api_key)

# Initialize model globally for reuse
model = genai.GenerativeModel('gemini-2.0-flash')

# System instruction for the Gemini model
SYSTEM_INSTRUCTION = """
You are a helpful assistant that answers in both Dhivehi and English. You provide concise, accurate, and helpful responses.
You maintain context throughout the conversation and use previous information when appropriate, but do not start responses with phrases like "As mentioned previously" or explicitly reference past messages.
If you don't know the answer to something, you acknowledge that instead of making things up.

IMPORTANT: Format your responses with English first, followed by two newlines, then the Dhivehi translation:

[English response here]

[Dhivehi response here]

Example interaction:
User: "What is the Dhivehi word for unique?"
Assistant: "The word for 'unique' is 'ލާސާނީ' (lāsānī) in the Dhivehi language.

'ޔުނީކް' އަށް ދިވެހިބަހުން ކިޔަނީ 'ލާސާނީ' އެވެ."
"""

def initialize_chat_session():
    """Initialize and return a new chat session with the model."""
    return model.start_chat(history=[
        {"role": "user", "parts": ["Please act as a helpful assistant with the following instructions:"]},
        {"role": "model", "parts": ["I'll act as a helpful assistant based on your instructions."]},
        {"role": "user", "parts": [SYSTEM_INSTRUCTION]},
        {"role": "model", "parts": ["I understand. I'll be a helpful assistant that provides concise, accurate responses while maintaining context throughout our conversation. I'll refer back to previous messages when appropriate, and I'll be honest when I don't know something instead of making up information."]}
    ])

def get_gemini_response(messages):
    """
    Get a response from Gemini based on message history and format it properly.
   
    Args:
        messages: List of message dictionaries with 'role' and 'content' keys
   
    Returns:
        String response from Gemini with English and Dhivehi properly separated
    """
    try:
        # Create a new chat session
        chat = initialize_chat_session()
       
        # Add all previous messages to build context
        # Skip the first system messages that were already added during initialization
        for message in messages:
            if message['role'] == 'user':
                chat.send_message(message['content'])
            # We don't need to add model responses as they're generated by the API
       
        # Get the response for the last message
        if messages and messages[-1]['role'] == 'user':
            response = chat.send_message(messages[-1]['content'])
            
            # Once we get the response
            raw_text = response.text
            
            # Post-process the response to separate English and Dhivehi
            import re
            dhivehi_pattern = re.compile(r'[\u0780-\u07BF]')
            match = dhivehi_pattern.search(raw_text)
            
            if match:
                # Find the position of the first Dhivehi character
                first_dhivehi_pos = match.start()
                
                # Look for a natural break point before the first Dhivehi character
                # Try to find a period followed by whitespace before the Dhivehi text
                natural_break = raw_text[:first_dhivehi_pos].rfind('.')
                if natural_break != -1 and natural_break > first_dhivehi_pos - 100:  # Don't cut too far back
                    split_pos = natural_break + 1
                else:
                    split_pos = first_dhivehi_pos
                
                # Split the text into English and Dhivehi parts
                english_part = raw_text[:split_pos].strip()
                dhivehi_part = raw_text[split_pos:].strip()
                
                # Combine with proper formatting (double newline)
                formatted_response = f"{english_part}\n\n{dhivehi_part}"
                return formatted_response
            else:
                # If no Dhivehi characters found, return the original text
                return raw_text
            
        else:
            # If the last message isn't from the user, let's handle that case
            current_app.logger.warning("Last message in the conversation is not from user")
            return "I'm sorry, I couldn't process that request correctly."
           
    except Exception as e:
        current_app.logger.error(f"Error communicating with Gemini API: {e}")
        return f"I apologize, but I encountered an error: {str(e)}"

def process_conversation_messages(conversation_id, db_module):
    """
    Process all messages for a conversation and return Gemini-compatible format.
    
    Args:
        conversation_id: ID of the conversation
        db_module: Database module for fetching messages
        
    Returns:
        List of message dictionaries with 'role' and 'content' keys
    """
    db_messages = db_module.get_messages(conversation_id)
    
    # Convert DB messages to Gemini format
    gemini_messages = []
    for msg in db_messages:
        # Map 'akuru' role to 'assistant' for compatibility with standard conventions
        role = 'assistant' if msg['role'] == 'akuru' else msg['role']
        gemini_messages.append({
            'role': role,
            'content': msg['content']
        })
    
    return gemini_messages