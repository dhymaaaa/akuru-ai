import os
import google.generativeai as genai
from dotenv import load_dotenv
from flask import current_app

# Load environment variables
load_dotenv()

# Get the Gemini API key from the environment variables
api_key = os.getenv("GEMINI_API_KEY")

if not api_key:
    raise ValueError("GEMINI_API_KEY environment variable not set.")

# Configure the Gemini API 
genai.configure(api_key=api_key)

# Initialize model globally for reuse
model = genai.GenerativeModel('gemini-2.0-flash')

# System instruction for the Gemini model
SYSTEM_INSTRUCTION = """
You are a friendly and patient Dhivehi language learning assistant. Your role is to help users learn Dhivehi in a supportive, encouraging way.

Key guidelines:
- Always be enthusiastic and supportive about language learning
- Never reference previous conversations or mention if a question was asked before
- Treat each question as fresh and new, even if it's repetitive
- Use phrases like "Great question!", "Let me explain that for you!"
- Be patient with learners who ask the same things multiple times
- Focus on being helpful rather than efficient but still focus on efficiency

IMPORTANT: Format your responses with English first, followed by a newline, then the Dhivehi translation:

[English response here]

[Dhivehi response here]

Example interaction:
User: "What is the Dhivehi word for unique?"
Assistant: "Great question! The word for 'unique' is 'ލާސާނީ' (lāsānī) in Dhivehi. It's a beautiful word!

'ޔުނީކް' އަށް ދިވެހިބަހުން ކިޔަނީ 'ލާސާނީ' އެވެ."
"""

def initialize_chat_session():
    """Initialize and return a new chat session with the model."""
    return model.start_chat(history=[
        {"role": "user", "parts": ["Please act as a friendly Dhivehi language learning assistant with the following instructions:"]},
        {"role": "model", "parts": ["I'm excited to help you learn Dhivehi! I'll be your friendly and patient language learning companion."]},
        {"role": "user", "parts": [SYSTEM_INSTRUCTION]},
        {"role": "model", "parts": ["Perfect! I understand. I'll be a friendly, enthusiastic Dhivehi language learning assistant. I'll treat every question as new and exciting, encourage repetition as part of learning, and always respond with both English and Dhivehi. I'm here to make your language learning journey enjoyable! What would you like to learn today?"]}
    ])

def get_gemini_response(messages):
    """
    Get a response from Gemini based on message history and format it properly.
   
    Args:
        messages: List of message dictionaries with 'role' and 'content' keys
   
    Returns:
        String response from Gemini with English and Dhivehi properly separated
    """
    try:
        # Create a new chat session
        chat = initialize_chat_session()
       
        # Add all previous messages to build context
        # Skip the first system messages that were already added during initialization
        for message in messages:
            if message['role'] == 'user':
                chat.send_message(message['content'])
            # We don't need to add model responses as they're generated by the API
       
        # Get the response for the last message
        if messages and messages[-1]['role'] == 'user':
            response = chat.send_message(messages[-1]['content'])
            
            # Once we get the response
            raw_text = response.text
            
            # Post-process the response to separate English and Dhivehi
            import re
            dhivehi_pattern = re.compile(r'[\u0780-\u07BF]')
            match = dhivehi_pattern.search(raw_text)
            
            if match:
                # Find the position of the first Dhivehi character
                first_dhivehi_pos = match.start()
                
                # Look for a natural break point before the first Dhivehi character
                # Try to find a period followed by whitespace before the Dhivehi text
                natural_break = raw_text[:first_dhivehi_pos].rfind('.')
                if natural_break != -1 and natural_break > first_dhivehi_pos - 100:  # Don't cut too far back
                    split_pos = natural_break + 1
                else:
                    split_pos = first_dhivehi_pos
                
                # Split the text into English and Dhivehi parts
                english_part = raw_text[:split_pos].strip()
                dhivehi_part = raw_text[split_pos:].strip()
                
                # Combine with proper formatting (double newline)
                formatted_response = f"{english_part}\n\n{dhivehi_part}"
                return formatted_response
            else:
                # If no Dhivehi characters found, return the original text
                return raw_text
            
        else:
            # If the last message isn't from the user, let's handle that case
            current_app.logger.warning("Last message in the conversation is not from user")
            return "I'm sorry, I couldn't process that request correctly."
           
    except Exception as e:
        current_app.logger.error(f"Error communicating with Gemini API: {e}")
        return f"I apologize, but I encountered an error: {str(e)}"

def process_conversation_messages(conversation_id, db_module):
    """
    Process all messages for a conversation and return Gemini-compatible format.
    
    Args:
        conversation_id: ID of the conversation
        db_module: Database module for fetching messages
        
    Returns:
        List of message dictionaries with 'role' and 'content' keys
    """
    db_messages = db_module.get_messages(conversation_id)
    
    # Convert DB messages to Gemini format
    gemini_messages = []
    for msg in db_messages:
        # Map 'akuru' role to 'assistant' for compatibility with standard conventions
        role = 'assistant' if msg['role'] == 'akuru' else msg['role']
        gemini_messages.append({
            'role': role,
            'content': msg['content']
        })
    
    return gemini_messages